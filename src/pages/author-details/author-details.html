<div transition:fade id="postWrap" class="content is-medium">
 <h1>{author_name}</h1>

 <table class="pure-table">
		<thead>
		  <tr>
			<th>category</th>
			<th>number posts</th>
		  </tr>
		</thead>
		<!-- <tfoot>
		  <tr>
			<th>name</th>
			<th>subject</th>
		  </tr>
		</tfoot> -->
		<tbody id='categories'>
		{#if $author && $author.cats}
		{#each $author.cats as cat}
		<tr>
		  <td class="linky" on:click="moveTo(cat.name)">{cat.name}</td>
		  <td>{cat.len}</td>
		</tr>
		{/each}
		{/if}
		  </tbody>
	</table>

	{#if $author && $author.cats}
{#each $author.cats as cat}
	<table id="{cat.name}" class="pure-table">
			<thead>
			  <tr>
			
				<th >post</th>
				<th width="250">date</th>
			</tr>
			</thead>
			<!-- <tfoot>
			  <tr>
				<th>name</th>
				<th>subject</th>
			  </tr>
			</tfoot> -->
			<tbody id='posts'>
	
			{#each cat.data as post, x}
			<tr>
			 
			  <td >
				<p class="postInfo">/{cat.name}/    article: <span><a href="{post.url}{post.id ? `#${post.id}` : ''}" target="_blank">{post.title}</a><span><span on:click="moveTo('postWrap')" class="pull-right">↑ top</span>
				</p>
				<p class="toolbar">
					<span on:click="saveData('pro',cat.name, post,x)" class="tb_pro">pro</span><span class="tb_con" on:click="saveData('con',cat.name, post,x)">con</span><span class="tb_note" on:click="saveData('note',cat.name, post,x)">add note</span>
				</p>
				<p class="posting">
				{post.post}
				</p>
				</td>
			  <td class="date">{post.date}<span class="right10">{post.mins}<span></td>			  
			</tr>
			{/each}
		
			  </tbody>
		</table>
			{/each}
		{/if}



</div>

<style>

iframe {
	width: 100%;
	height: 100vh;
}

blockquote {
	border-bottom-right-radius:4px;
	border-bottom-left-radius:4px;
	text-align: initial;
}
blockquote::before {
	content: '☼';
	font-size: 4rem;
}
#postWrap {
	padding-top:50px;
	padding-bottom:50px;
}

ol > li {
	font-size: 1.5rem;
	word-spacing: 5px;
    letter-spacing: .5px;
}

h1 {
		padding: 10px;
		padding-left: 50px;
		color:  black;
		border-radius: 0px;
		border-top-right-radius: 20px;
    /* border-bottom-right-radius: 20px; */
		margin-bottom:0;
		margin-top: 5px;
		box-shadow: 2px 2px 15px #ccc;
		-webkit-text-fill-color: black;
    -webkit-text-stroke-width: 1px;
    -webkit-text-stroke-color: black;
    -webkit-text-stroke-width: .2px;
    word-spacing: 15px;
	letter-spacing: 2px;		
	opacity: .8;
	}
h3 { 
	font-size: 2rem;
	margin-left:20px;
} 
.posting {
	word-break:break-word;
	padding-top:10px;
	padding-bottom:10px;
	border-bottom: solid 1px #ccc;
	font-family: 'Montserrat', sans-serif;
}

td {
	font-family: 'Montserrat', sans-serif;
}

</style> 

<script >
		import { fade } from 'svelte-transitions';		
		import { startCase } from '../../utilities.js';
		import { Toast, deleteAllToasts} from '../../toaster-js/index.js';   
  
 
  export default {
	transitions: { fade },
    store: () => store,
    components:{ 
	}, 
    methods: {
		moveTo(id) {
			let elmnt = document.getElementById(id);
			elmnt.scrollIntoView();	
		},
		saveData(type,cat,post, x) {
			let str = cat;
			// new Toast(str, 'modal','error', 0,[
			// 		{ text:'ok', action:'cancel'}])
			// 		return
			/* the x ties us to the index, which I don't like, but I don't see any other way right now
			as there are no unique ids accross the 3 blogs - stephen jones has no ids for comments. So basically this is lame and we can now only hide crap we may want to delete later, because it would screw up the index for everything saved to notebook
			*/
			let bookmarks = localStorage.getItem('bookmarks') || {};
			if (Object.keys(bookmarks).length > 0) bookmarks = JSON.parse(bookmarks);

			console.log(x+ ' cat is '+cat)
			console.log(x+ ' author is '+post.author)
			let id = `${post.author}_${cat}_${x}`
			let st;
			
			let obj = {
				id: id,
				cat: cat,
				title: post.title,
				post: post.post,
				author: post.author,
				url: post.url,
				date:post.date
			}
			
			if (bookmarks[id] && bookmarks[id].note) obj.note = bookmarks[id].note;

			switch (type) {
				case 'pro':
					obj.type = 'pro';				
					bookmarks[id] = obj;
					localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
					 st = 'saved '+post.title+ ' to notebook as supporting authenticity.'
					new Toast(st,'toast','success')
					break;
				case 'con':
					obj.type = 'con';				
					bookmarks[id] = obj;
					localStorage.setItem('bookmarks', JSON.stringify(bookmarks));					
					st = 'saved '+post.title+ ' to notebook as evidence against authenticity.'
					new Toast(st,'toast','error')
					break;			

				case 'note':
				    st = 'Enter or paste text:';
				    store.set({temp:obj})
					new Toast(str, 'modal', 'input', 0, [], 'note');
					break;
			}
		},
		addParagraphBreaks() {
			let comp = this;
			let postings = document.getElementsByClassName('posting');
			//console.log('got postings? '+postings)
			let j = 0;

			const authorsArr  = ['david', 'hugh', 'dan', 'colin', 'yannick', 'charles', 'daveb', 'max', 'stephen', 'mario', 'mark', 'antonio', 'john', 'giulio', 'louis', 'anoxie', 'dave', 'kelly', 'barry', 'barrie', 'russ', 'joe', 'colinsberry', 'ron'];
			const scholars = ['barbet','rucker','zugibe', 'wesselow', 'piczak', 'piczek', 'benford','vignon', 'bucklin', 'marino','rolfe', 'meacham', 'fanti', 'rogers', 'adler', 'heller', 'mccrone', 'jackson', 'strup', 'enea']
			const shroudWords = ['pray', 'codex', 'tomb', 'cloth', 'textile', 'shroud', 'woven', 'ancient', 'formation', 'pollen', 'dna']
			const bloodWords = ['blood', 'bloodstains', 'bloodstain', 'bloody', 'wounds'];
			const holyWords = ['christ', 'yeshua','jesus', 'god', 'holy', 'spirit', 'trinity', 'lord', 'lords']
			alterPost(j);
			
			
			function alterPost(j) { 
				if (j > postings.length-1) return
//			for (let posting of postings) {
	
				let str = postings[j].textContent.replace(/\\n/g, '');
				//console.log(str)
			
				let arr = [];

				let words = str.split(' ');
			
				//let result = this.chunkArray(str, 50);
				let newStr = '';
				let lines = [];

				let i = 0; // for lines
				let e = 0; // for words
				let z = 0;
		
				
				for (let word of words) {
					// fix people like Charles Freeman who are always adding commas w/ no space after them...
					word = word.replace(/,[s]*/g, ", ");

					let line = lines[i] || '';	
					//console.log(word)
					if (authorsArr.includes(word.trim().toLowerCase().replace('-','').replace('“', '').replace(',', '').replace('.', ''))) {
						word = '<span class="authorName">'+word+'</span>';
					}
					if (scholars.includes(word.trim().toLowerCase().replace('“', '').replace('’s', '').replace(',', '').replace('.', ''))) {
						word = '<span class="scholars">'+word+'</span>';
					}


					if (bloodWords.includes(word.trim().toLowerCase().replace('“', '').replace(',', '').replace('.', ''))) {
						word = '<span class="blood">'+word+'</span>';
					}

					if (shroudWords.includes(word.trim().toLowerCase().replace('“', '').replace(',', '').replace('.', ''))) {
						word = '<span class="shroud">'+word+'</span>';
					}
	
					if (holyWords.includes(word.trim().toLowerCase().replace('“', '').replace(',', '').replace('.', '').replace('’s', ''))) {
						word = '<span class="holy">'+word+'</span>';
					}				

					line = line + ' ' + word;
					lines[i] = line;
					e++
					if (e > 50 && word.includes('.') || e > 50 && word.includes('!')) {
						e = 0;
						//console.log("\n\nGOT A HIT")
						i++;
					}
				}
				for (let line of lines) {
					//console.log(line)
					line = comp.urlify(line);
					newStr = newStr + '<p>'+line+'</p>'
				}
				postings[j].innerHTML =  newStr;
				j++
				setTimeout(() => {
					alterPost(j);
				}, 50);
			
			}
		},
		urlify(text) {
			let urlRegex = /(((https?:\/\/)|(www\.))[^\s]+)/g;
			//var urlRegex = /(https?:\/\/[^\s]+)/g;
			return text.replace(urlRegex, function(url,b,c) {
			
			let url2 = (c == 'www.') ?  'http://' +url : url;
				url2 = url2.replace(')', '').replace('(', '')
			
				return '<a href="' +url2.toLowerCase()+ '" target="_blank">' + url.toLowerCase() + '</a>';
			}) 
		},
		chunkArray(myArray, chunk_size){
			var index = 0;
			var arrayLength = myArray.length;
			var tempArray = [];

			for (let index = 0; index < arrayLength; index += chunk_size) {
		
				let myChunk = myArray.slice(index, index+chunk_size);
				// Do something if you want with the group
				
				tempArray.push(myChunk);
			}

			return tempArray;
		}
    },
	computed: {
		author_name: ( { $id }) => {
		let name = $id.replace(/_/g, ' ');
			name = startCase(name);
		return name 
		}
	},

	oncreate() {
		let right = document.getElementsByClassName('right')[0];
      if (right) console.log('GOT RIGHT')
      right.style.backgroundColor = '#f1ebda';
      right.style.backgroundImage = 'none';
      right.classList.remove('has-background-white-ter')
		const state = store.get();
		const id = state.id;
		console.log('dawg id is '+id)
		console.log('id is '+id)

		const comp = this;

		const urly = `../data/authors_master/${ id }.json`;
		return fetch(urly).then(function(res) {
		return res.json();
			})
			.then(function(json) {
			let arr = [];
		     for (let cat in json) {
				 arr.push({name: cat, len: json[cat].length, data:json[cat]})
			 }
			 setTimeout(() => {
			   console.log('adding Par.breaks')
				comp.addParagraphBreaks();
				//comp.shortenDates();
				for (let cat in json) {
					new Tablesort(document.getElementById(cat));
				}
			}, 2000);
			store.set({author: {name: id, cats: arr} })

			});

		}  // end oncreate()
}
</script>